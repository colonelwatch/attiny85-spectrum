<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSD1306 OLED display driver: nano_engine/README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SSD1306 OLED display driver
   &#160;<span id="projectnumber">1.7.20</span>
   </div>
   <div id="projectbrief">This library is developed to control SSD1306/SSD1331/SSD1351/IL9163/PCD8554 RGB i2c/spi LED displays</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">nano_engine/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Using NanoEngine for systems with low resources</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;***</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;[tocstart]: # (toc start)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  * [Introduction](#introduction)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  * [Main idea of NanoEngine](#main-idea-of-nanoengine)</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  * [Simple NanoEngine demo](#simple-nanoengine-demo)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  * [Reading keys with NanoEngine](#reading-keys-with-nanoengine)</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  * [Draw monochrome bitmap](#draw-monochrome-bitmap)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  * [Draw moving bitmap](#draw-moving-bitmap)</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  * [What if not to use draw callbacks](#what-if-not-to-use-draw-callbacks)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  * [Using Adafruit GFX with NanoEngine](#using-adafruit-gfx-with-nanoengine)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  * [To upper level](@ref index)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;[tocend]: # (toc end)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;&lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;## Introduction</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;Many applications use double-buffered output to physical display to avoid flickering effect, when a user observed non-completed picture for a short time. When working with color OLED/LCD displays like ssd1331, some micro-controllers do not have enough RAM to fit display buffer in. For example, in 8-bit mode ssd1331 OLED display needs 6144 bytes (`96*64`). But simple micro-controller like Atmega328 has only 2KiB, and Attiny85 has only 512B of RAM. But with ssd1306 library you still can create applications for those ones with good graphics.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;ssd1306 library represents NanoEngine8, intended to be used with color OLED displays. Digit 8 means that engine implements 8-bit color mode. Refer to arkanoid8 as example, which can be run even on small Attiny85 with color ssd1331 display. The system supports NanoEngine1 for monochrome OLED displays, NanoEngine8 for 8-bit RGB OLED displays, NanoEngine16 for 16-bit RGB OLED displays.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;&lt;a name=&quot;main-idea-of-nanoengine&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;## Main idea of NanoEngine</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;There are 2 issues with tiny controllers:</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  * they have a little RAM</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  * they support low frequencies</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;The first problem is solved in NanoEngine by using double-buffer to redraw only part of display content at once. By default NanoEngine uses 8x8 small buffer (64 bytes) and 24 bytes to store information on areas, which need to be refreshed.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;The second problem is solved almost the same way: refresh only those part of display content, which were changed since last frame update. For example, ssd1331 oled display work on SPI at 8MHz frequency, that means in ideal conditions the screen content can be refreshed 162 times per second (`8000000/(96*64*8)`). But with the data, you need to send also commands to the display and to do some other stuff. And real tests with Atmega328p show that `ssd1306_clearScreen()` can run only at 58 FPS, coping data from buffer to OLED memory runs slower. </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;There is no such issue for Arduboy, since it uses monochrome OLED ssd1306 with only 1KiB of RAM buffer, and theoretical fps can be up to 976. For color display and small controllers the main solution is to refresh only part of display content. Arkanoid8 can give easily 60 fps with NanoEngine8</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;&lt;a name=&quot;simple-nanoengine-demo&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;## Simple NanoEngine demo</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;```cpp</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;NanoEngine8 engine;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;bool drawAll()</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    engine.canvas.clear();</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    engine.canvas.setColor(RGB_COLOR8(255,255,0));</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    engine.canvas.drawRect(15,12,70,55);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    return true;   // if to return false, the engine will skip this part of screen update</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;void setup()</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;{</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    /* Init SPI 96x64 RBG oled. 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C */</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    ssd1331_96x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    engine.begin();</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    engine.setFrameRate(30);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    /* Set callback to draw parts, when NanoEngine8 asks */</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    engine.drawCallback( drawAll );</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;void loop()</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;{</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    engine.refresh();  // Makes engine to refresh whole display content</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    engine.display();</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;```</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;&lt;a name=&quot;reading-keys-with-nanoengine&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;## Reading keys with NanoEngine</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;What, if we want to move yellow rectangle. There is easy way to do this with NanoEngine8. The engine supports up-to 6 keys: `BUTTON_DOWN`, `BUTTON_LEFT`, `BUTTON_RIGHT`, `BUTTON_UP`, `BUTTON_A`, `BUTTON_B`. All you need is to say the engine how it can get buttons state on your board. There are already 2 built-in implementations: `connectArduboyKeys()` allows using Arduboy platform hardware (remember that you need to replace ssd1306 oled with color ssd1331 oled), and `connectZKeypad()` allows using standard 5-keys Z-keypad (you can find it on E-bay). Or you can set custom key processing handler via `connectCustomKeys()` and implement your own hardware driver.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;Example of using Z-keypad to move rectangle.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;```cpp</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;NanoEngine8 engine;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;NanoRect rect = { {15,12}, {60,35} }; // Lets make rect smaller than in previous example</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;bool drawAll()</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    engine.canvas.clear();</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    engine.canvas.setColor(RGB_COLOR8(255,255,0));</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    engine.canvas.drawRect(rect);   // draw rect in buffer</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    return true;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;}</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;void setup()</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;{</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    /* Init SPI 96x64 RBG oled. 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C */</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    ssd1331_96x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    engine.begin();</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    engine.setFrameRate(30);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    engine.drawCallback( drawAll );  // Set callback to draw parts, when NanoEngine8 asks</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    engine.connectZKeypad(0);        // Connect ADC-buttons Z-keypad to analog A0 pin</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    engine.refresh();                // Makes engine to refresh whole display content at start-up</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;void loop()</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;{</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    NanoPoint point = {0,0};</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    if (engine.pressed( BUTTON_RIGHT )) point.x = +1;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    if (engine.pressed( BUTTON_LEFT ))  point.x = -1;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    if (engine.pressed( BUTTON_UP ))    point.y = -1;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    if (engine.pressed( BUTTON_DOWN ))  point.y = +1;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    engine.refresh(rect);            // Update screen content at old rect position</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    rect += point;                   // Move rect according to pressed keys</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    engine.refresh(rect);            // Update screen content at new rect position</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    engine.display();                // refresh display content</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;```</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;&lt;a name=&quot;draw-monochrome-bitmap&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;## Draw monochrome bitmap</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;```cpp</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;NanoEngine8 engine;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;const uint8_t heartSprite[8] PROGMEM =</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;{</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    0B00001110,</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    0B00011111,</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    0B00111111,</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    0B01111110,</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    0B01111110,</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    0B00111101,</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    0B00011001,</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    0B00001110</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;};</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;bool drawAll()</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;{</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    engine.canvas.clear();</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    engine.canvas.setMode(0);  // We want to draw non-transparent bitmap</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    engine.canvas.setColor(RGB_COLOR8(255,0,0));  // draw with red color</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    engine.canvas.drawBitmap1(10, 20, 8, 8, heartSprite);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    return true;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;}</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;void setup()</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;{</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    /* Init SPI 96x64 RBG oled. 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C */</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    ssd1331_96x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    engine.begin();</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    engine.drawCallback( drawAll );  // Set callback to draw parts, when NanoEngine8 asks</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    engine.refresh();                // Makes engine to refresh whole display content at start-up</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;}</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;void loop()</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    engine.display();                // refresh display content</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;```</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;&lt;a name=&quot;draw-moving-bitmap&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;## Draw moving bitmap</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;In some applications like games, there is need to move bitmaps. It is easy to do this with ssd1306 library using NanoSprite objects. NanoSprite object is responsible for refreshing areas, touched by sprite. So, you need only to move sprite, where you want, the engine will take care of updating display content.</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;```cpp</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;const uint8_t heartSprite[8] PROGMEM =</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;{</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    0B00001110,</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    0B00011111,</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    0B00111111,</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    0B01111110,</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    0B01111110,</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    0B00111101,</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    0B00011001,</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    0B00001110</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;};</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;NanoEngine8 engine;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;NanoSprite&lt;NanoEngine8, engine&gt; sprite( {0, 0}, {8, 8}, heartSprite );</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;bool drawAll()</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;{</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    engine.canvas.clear();</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    engine.canvas.setMode(0);  // We want to draw non-transparent bitmap</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    engine.canvas.setColor(RGB_COLOR8(255,0,0));  // draw with red color</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    sprite.draw();</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    return true;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;}</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;void setup()</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;{</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    /* Init SPI 96x64 RBG oled. 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C */</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    ssd1331_96x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    engine.begin();</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    engine.drawCallback( drawAll );  // Set callback to draw parts, when NanoEngine8 asks</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    engine.refresh();                // Makes engine to refresh whole display content at start-up</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;void loop()</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    // You will see horizontal flying heart</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    sprite.moveBy( { 1, 0 } );</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    engine.display();                // refresh display content</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;}</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;```</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;&lt;a name=&quot;what-if-not-to-use-draw-callbacks&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;## What if not to use draw callbacks</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;If you don&#39;t want to use draw callbacks in your application, but still need a power of NanoEngine, then there is one way for you: to use full-screen double-buffering with NanoEngine. The example, you will find below, shows how to use full-screen double buffering for monochrome 128x64 ssd1306 oled display. This example can be run on Atmega328p and more powerful micro controllers. It clears back-buffer every time engine says to redraw the frame. But you can preserve previously prepared image by removing call to `engine.canvas.clear()`.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;```cpp</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;NanoEngine&lt;BUFFER_128x64_MONO&gt; engine;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;void setup()</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;{</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    // Init SPI 128x64 monochrome oled.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    // 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    ssd1306_128x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    engine.begin();</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    engine.setFrameRate(30);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;}</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;void loop()</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;{</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    engine.canvas.clear();    // This step can be removed, if you don&#39;t want to clear buffer</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    engine.canvas.drawRect(15,12,70,55);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    engine.display();</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;}</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;```</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;&lt;a name=&quot;using-adafruit-gfx-with-nanoengine&quot;&gt;&lt;/a&gt;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;## Using Adafruit GFX with NanoEngine</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;Many developers are familiar with nice AdafruitGFX library. It provides rich set of graphics functions. Starting with 1.7.0 ssd1306 library it is possible to use AdafruiGFX api in combination with NanoEngine. And it is really easy.</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;You need to remember only, that AdafruitGFX uses different approach, when working with rectangles and monochrome images. NanoCanvas expects monochrome bitmaps in native ssd1306 format, while Adafruit uses more native format for human. If you compare an example below with examples above you will understand, what&#39;s the difference (heartImage). Refer to AdafruitGFX documentation.</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;```cpp</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;// Define this before including library header, this will give Adafruit GFX support</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;// !!! Don&#39;t forget to install AdafruitGFX library to your Arduino IDE !!!</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;#define CONFIG_ADAFRUIT_GFX_ENABLE</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;#include &quot;ssd1306.h&quot;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;#include &quot;nano_engine.h&quot;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;// Now you can use AdafruitGFX by referencing engine.canvas</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;NanoEngine&lt;ADATILE_8x8_RGB8&gt; engine;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;const PROGMEM uint8_t heartImage[8] =</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;{</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    0B01100110,</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    0B11111001,</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    0B11111101,</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    0B11111111,</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    0B01111110,</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    0B00111100,</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    0B00011000,</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    0B00000000</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;};</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;bool drawAll()</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;{</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    engine.canvas.fillScreen( 0 );</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    engine.canvas.drawBitmap(10, 20, heartSprite, 8, 8, RGB_COLOR8(255,0,0)); // draw bitmap with red color</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    return true;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;}</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;void setup()</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;{</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    /* Init SPI 96x64 RBG oled. 3 - RESET, 4 - CS (can be omitted, oled CS must be pulled down), 5 - D/C */</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    ssd1331_96x64_spi_init(3, 4, 5);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    engine.begin();</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    engine.drawCallback( drawAll );  // Set callback to draw parts, when NanoEngine8 asks</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    engine.refresh();                // Makes engine to refresh whole display content at start-up</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;}</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;void loop()</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;{</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    if (!engine.nextFrame()) return;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    engine.display();                // refresh display content</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;}</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;```</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
